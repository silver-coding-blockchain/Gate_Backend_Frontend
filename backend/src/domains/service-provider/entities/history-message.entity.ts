import {
  Entity,
  Enum,
  Index,
  ManyToOne,
  PrimaryKey,
  PrimaryKeyType,
  Property,
  Unique,
} from '@mikro-orm/core';
import { Field, ID, ObjectType, registerEnumType } from '@nestjs/graphql';
import { v4 as uuidv4 } from 'uuid';
import { pick } from 'lodash';
import {
  MessageType,
  ParticipantField,
} from '@app/interfaces/service-provider/service-provider.enums';
import { ConnectionEmailMessageInterface } from '@app/interfaces/service-provider/message.interface';

import ChallengeEntity from '../../challenge/entities/challenge.entity';
import DecisionEntity from '../../gatekeeper/entities/decision.entity';

import HistoryThreadEntity from './history-thread.entity';
import ConnectionEntity from './connection.entity';
import { MessageParticipantEntity } from './message-participant.entity';

interface AddFields {
  thread?: HistoryThreadEntity;
  connection: ConnectionEntity;
}

interface IHistoryMessageEntity
  extends Omit<ConnectionEmailMessageInterface, 'labels'>,
    AddFields {}

export type ConnectionMessageFields = Pick<
  ConnectionEmailMessageInterface,
  | 'bcc'
  | 'cc'
  | 'externalMessageId'
  | 'from'
  | 'isMailingList'
  | 'receivedAt'
  | 'replyTo'
  | 'to'
  | 'type'
  | 'userId'
  | 'wasSentBySystem'
>;

// to maintain backward compatibility, though this field isn't actually used
export type ConnectionMessageFieldsWithCalendarEvent = ConnectionMessageFields &
  Pick<ConnectionEmailMessageInterface, 'calendarEvent'>;

export interface IHistoryMessageEntityConstructor
  extends ConnectionMessageFieldsWithCalendarEvent,
    AddFields {}

registerEnumType(MessageType, { name: 'MessageTypeEnum' });
registerEnumType(ParticipantField, { name: 'ParticipantFieldEnum' });

@ObjectType('Message')
@Entity({ tableName: 'service_provider_messages' })
@Index({ properties: ['userId', 'type', 'wasSentBySystem'] })
@Index({ properties: ['to', 'cc', 'bcc'], type: 'gin' })
export default class HistoryMessageEntity
  extends ConnectionEmailMessageInterface
  implements IHistoryMessageEntity
{
  @PrimaryKey({ type: 'uuid', fieldName: 'id' })
  @Field(() => ID, { name: 'id' })
  override messageId!: string;

  [PrimaryKeyType]!: string;

  @Field(() => ConnectionEntity)
  @ManyToOne()
  connection: ConnectionEntity;

  @Property({ type: 'uuid' })
  @Index()
  override userId!: string;

  @ManyToOne({ nullable: true })
  @Field(() => HistoryThreadEntity, { nullable: true })
  thread?: HistoryThreadEntity;

  @Unique()
  @Property()
  override externalMessageId!: string;

  @Property({ type: 'json' })
  @Field(() => [MessageParticipantEntity])
  override to!: MessageParticipantEntity[];

  @Property({ type: 'json' })
  @Field(() => MessageParticipantEntity)
  override from!: MessageParticipantEntity;

  @Property({ type: 'json' })
  @Field(() => [MessageParticipantEntity])
  override cc!: MessageParticipantEntity[];

  @Property({ type: 'json' })
  @Field(() => [MessageParticipantEntity])
  override bcc!: MessageParticipantEntity[];

  @Property({ type: 'json' })
  @Field(() => [MessageParticipantEntity])
  override replyTo!: MessageParticipantEntity[];

  @Enum(() => MessageType)
  @Field(() => MessageType)
  override type!: MessageType;

  @Property()
  @Field()
  @Index()
  override receivedAt!: Date;

  @Property({ nullable: true })
  @Field({ nullable: true })
  createdAt?: Date;

  @Property()
  @Field()
  override wasSentBySystem!: boolean;

  @Property()
  @Field()
  override isMailingList!: boolean;

  @Property()
  @Field()
  isAnonymized: boolean;

  @Property({ nullable: true })
  @Field({ nullable: true })
  override isAutomated?: boolean;

  @Property({ persist: false })
  get connectionId(): string {
    return this.connection.connectionId;
  }

  @Property({ persist: false })
  get threadId(): string | undefined {
    return this.thread?.threadId;
  }

  constructor(props: IHistoryMessageEntityConstructor) {
    const overrideProps = {
      messageId: uuidv4(),
      connectionId: props.connection.connectionId,
      threadId: props.thread?.threadId,
    };

    const fields = HistoryMessageEntity.mapFieldsFromMessage(props);

    super({
      ...fields,
      ...overrideProps,
    });

    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    // this is needed to prevent this non persisted field to be generated by the knex query builder
    delete this.isDraft;

    if (props.thread) {
      this.thread = props.thread;
    }
    this.connection = props.connection;
    this.createdAt = new Date();
    this.isAnonymized = false;
  }

  // graphql extensions
  @Field(() => ChallengeEntity, { nullable: true })
  challenge?: ChallengeEntity;

  @Field(() => DecisionEntity, { nullable: true })
  decision?: DecisionEntity;

  static mapFieldsFromMessage(
    message: ConnectionMessageFields,
  ): ConnectionMessageFields {
    return pick(message, [
      'bcc',
      'cc',
      'externalMessageId',
      'from',
      'isMailingList',
      'receivedAt',
      'replyTo',
      'to',
      'type',
      'userId',
      'wasSentBySystem',
    ]);
  }
}
